<html>
    <head>
    <script src="seedrandom.js"/>
    </head>
    <body>
        http://www.astrolog.org/labyrnth/algrithm.htm
        http://www.diveintohtml5.org/canvas.html
        Recursive division: This algorithm is somewhat similar to recursive backtracking, since they're both stack based, except this focuses on walls instead of passages. Start by making a random horizontal or vertical wall crossing the available area in a random row or column, with an opening randomly placed along it. Then recursively repeat the process on the two subareas generated by the dividing wall. For best results, give bias to choosing horizontal or vertical based on the proportions of the area, e.g. an area twice as wide as it is high should be divided by a vertical wall more often. This is the fastest algorithm without directional biases, although it has the obvious blemish of long walls crossing the interior. This algorithm is a form of nested fractal Mazes, except instead of always making fixed cell size Mazes with Mazes of the same size within each cell, it divides the given area randomly into a random sized 1x2 or 2x1 Maze. Recursive division doesn't work as a passage carver, because doing so results in an obvious solution path that either follows the outside edge or else directly crosses the interior.<br/>
        <canvas id="maze" width="401" height="401" class=clear style="float:left"></canvas>
        <script>
            var maze_canvas = document.getElementById("maze");
            var maze_context = maze_canvas.getContext("2d");
            drawMaze();
            
            function drawMaze() {
                Math.seedrandom();

//            for (var x = 0.5; x < 400; x += 100) {
//                maze_context.moveTo(x, 0);
//                maze_context.lineTo(x, 400);
//            }

//            for (var y = 0.5; y < 400; y += 100) {
//                maze_context.moveTo(0, y);
//                maze_context.lineTo(400, y);
//            }

//            maze_context.strokeStyle = "#fff";
//            maze_context.stroke();

                divideArea(0.5, 0.5, 400, 400, 20, maze_context);

                // top line
                maze_context.moveTo(0.5, 0.5);
                maze_context.lineTo(400.5, 0.5);
                // bottom line
                maze_context.moveTo(0.5, 400.5);
                maze_context.lineTo(400.5, 400.5);
                // left line
                maze_context.moveTo(0.5, 0.5);
                maze_context.lineTo(0.5, 200.5);
                maze_context.moveTo(0.5, 220.5);
                maze_context.lineTo(0.5, 400.5);
                // right line
                maze_context.moveTo(400.5, 0.5);
                maze_context.lineTo(400.5, 200.5);
                maze_context.moveTo(400.5, 220.5);
                maze_context.lineTo(400.5, 400.5);
                maze_context.strokeStyle = "#000";
                maze_context.stroke();

            
                maze_canvas.addEventListener("mousemove", fillCell, false);
                maze_canvas.addEventListener("touchmove", fillCell2, true);
            }

            function fillCell(e) {
                getCursorPosition(e);
            }

            function fillCell2(e) {
    if (!e) var e = event;
    e.preventDefault();
    canX = e.targetTouches[0].pageX - maze_canvas.offsetLeft;
    canY = e.targetTouches[0].pageY - maze_canvas.offsetTop;
    maze_context.fillRect(canX, canY, 10, 10);
}
function getCursorPosition(e) {
    /* returns Cell with .row and .column properties */
    var x;
    var y;
    if (e.pageX != undefined && e.pageY != undefined) {
	x = e.pageX;
	y = e.pageY;
    }
    else {
	x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
	y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    x -= maze_canvas.offsetLeft;
    y -= maze_canvas.offsetTop;
    x = Math.min(x, 400);
    y = Math.min(y, 400);
    maze_context.fillRect(x, y, 10, 10)
//    var cell = new Cell(Math.floor(y/20), Math.floor(x/20));
//    return cell;
}
            
            function divideArea(x, y, width, height, cell_size, maze_context) {
                    if (height == cell_size) return;
                    if (width == cell_size) return;
//                document.writeln("X:"+x+" Y:"+y+" width:"+width+" height:"+height+"<br/>");
//                var conf = confirm("X:"+x+" Y:"+y+" width:"+width+" height:"+height);
//                if (!conf) {
//                    return;
//                }
                // horizontal or vertical?
                var horizontal = orientation(width, height);
                if (horizontal) {
                    var draw_at = Math.ceil(Math.random()*(height-cell_size)/cell_size);
//                    var draw_at = Math.floor(Math.random()*(height+cell_size)/cell_size);
                    var opening_at = Math.floor(Math.random()*width/cell_size);
//                    document.writeln("ho draw_at:"+draw_at+" opening_at:"+opening_at+"<br/>");
//                    var conf2 = confirm("ho draw_at:"+draw_at+" opening_at:"+opening_at);
//                    if (!conf2) {
//                        return;
//                    }
                    maze_context.moveTo(x, y+draw_at*cell_size);
                    maze_context.lineTo(x+opening_at*cell_size, y+draw_at*cell_size);
                    maze_context.moveTo(x+opening_at*cell_size+cell_size, y+draw_at*cell_size);
                    maze_context.lineTo(x+width, y+draw_at*cell_size);
            maze_context.strokeStyle = "#000";
            maze_context.stroke();
//                    if (width > cell_size || draw_at*cell_size > cell_size) {
                        divideArea(x, y, width, draw_at*cell_size, cell_size, maze_context);
//                    }
//                    if (width > cell_size || height-draw_at*cell_size > cell_size) {
                        divideArea(x, y+draw_at*cell_size, width, height-draw_at*cell_size, cell_size, maze_context);
//                    }
                } else {
                    var draw_at = Math.ceil(Math.random()*(width-cell_size)/cell_size);
//                    var draw_at = Math.floor(Math.random()*(width+cell_size)/cell_size);
                    var opening_at = Math.floor(Math.random()*height/cell_size);
//                    document.writeln("vert draw_at:"+draw_at+" opening_at:"+opening_at+"<br/>");
//                    var conf2 = confirm("vert draw_at:"+draw_at+" opening_at:"+opening_at);
//                    if (!conf2) {
//                        return;
//                    }
                    maze_context.moveTo(x+draw_at*cell_size, y);
                    maze_context.lineTo(x+draw_at*cell_size, y+opening_at*cell_size);
                    maze_context.moveTo(x+draw_at*cell_size, y+opening_at*cell_size+cell_size);
                    maze_context.lineTo(x+draw_at*cell_size, y+height);
            maze_context.strokeStyle = "#000";
            maze_context.stroke();
//                    if (draw_at*cell_size > cell_size || height > cell_size) {
                        divideArea(x, y, draw_at*cell_size, height, cell_size, maze_context);
//                    }
//                    if (width-draw_at*cell_size > cell_size || height > cell_size) {
                        divideArea(x+draw_at*cell_size, y, width-draw_at*cell_size, height, cell_size, maze_context);
//                    }
                }
            }
            function orientation(width, height) {
                if (height > 2*width)
                return 1;
                else if (width > 2*height)
                return 0;
                else
                return Math.round(Math.random());
            }
        </script>
    </body>
</html>

